---
import invariant from "tiny-invariant";
import { keystatic } from "@lib/keystatic/client";
import Button from "./Button.astro";
import ArrowRight from "@lucide/astro/icons/arrow-right";
import Link from "./Link.astro";
import KeystaticImage from "./KeystaticImage.astro";
import { Icon } from "astro-icon/components";

const i18n = await keystatic.singletons.nav.read({
  resolveLinkedFiles: true,
});
invariant(i18n, "No homepage content found");
---

<div class="px-base fixed top-[15px] right-0 left-0 z-50">
  <div
    class="max-w-container mx-auto flex h-[90px] w-full items-center justify-between"
  >
    <div class="flex h-full w-[10px] items-center justify-center">
      <div class="h-full max-h-[calc(100%-20px)] w-[5px] bg-black"></div>
      <div
        class="h-full max-h-[calc(100%-10px)] w-[5px] border-y-5 border-y-black bg-white"
      >
      </div>
    </div>
    <nav
      class="flex h-full w-full items-center justify-between border-y-5 border-y-black bg-white p-[15px]"
    >
      <div class="lg:w-[227px]">
        <a href={i18n.logo.href} aria-label="Go to homepage">
          <KeystaticImage
            src={i18n.logo.image}
            alt={i18n.logo.alt ?? ""}
            class="h-[50px]"
          />
        </a>
      </div>

      <div class="hidden items-center space-x-[50px]">
        {
          i18n.navigationLinks.map((link) => (
            <Link
              href={link.href}
              target={link.newTab ? "_blank" : undefined}
              rel={link.newTab ? "noopener noreferrer" : undefined}
              class="t-lg"
            >
              {link.label}
            </Link>
          ))
        }
      </div>
      
      <div class="flex items-center space-x-4">
        <Button
          href="https://github.com/patroninc/patron"
          as="a"
          color="secondary"
          target="_blank"
          rel="noopener noreferrer"
          shadow={false}
        >
          <Icon name='simple-icons:github' class="h-6 w-6" />

          <span id="star-count">
            <span class="skeleton-loader animate-pulse bg-gray-300 rounded h-4 w-5 inline-block"></span>
          </span>
        </Button>
        
        {
          i18n.ctaButton.enabled && (
            <Button shadow={false} as="button" type="button" id="nav-cta-button">
              <span class="inline sm:hidden">{i18n.ctaButton.shortLabel}</span>
              <span class="hidden sm:inline">{i18n.ctaButton.label}</span>
              <ArrowRight />
            </Button>
          )
        }
      </div>
    </nav>
    <div class="flex h-full w-[10px] items-center justify-center">
      <div
        class="h-full max-h-[calc(100%-10px)] w-[5px] border-y-5 border-y-black bg-white"
      >
      </div>
      <div class="h-full max-h-[calc(100%-20px)] w-[5px] bg-black"></div>
    </div>
  </div>
</div>

<script>
  const navCtaButton = document.getElementById("nav-cta-button");

  function getPageY(el: Element) {
    const rect = el.getBoundingClientRect();
    return rect.top + window.scrollY + rect.height / 2;
  }

  function findNearestEmailInput(): HTMLInputElement | null {
    const hero = document.getElementById("waitlist-email-hero") as HTMLInputElement | null;
    let footer = document.getElementById("waitlist") as HTMLInputElement | null;

    // Fallback in case the footer input doesn't have the expected ID
    if (!footer) {
      footer = document.querySelector('form#end-cta input[type="email"]') as HTMLInputElement | null;
    }

    const candidates = [hero, footer].filter(Boolean) as HTMLInputElement[];
    if (candidates.length === 0) return null;

    const currentY = window.scrollY + window.innerHeight / 2;
    let nearest = candidates[0];
    let minDist = Math.abs(getPageY(nearest) - currentY);

    for (let i = 1; i < candidates.length; i++) {
      const d = Math.abs(getPageY(candidates[i]) - currentY);
      if (d < minDist) {
        minDist = d;
        nearest = candidates[i];
      }
    }
    return nearest;
  }

  if (navCtaButton) {
    navCtaButton.addEventListener("click", () => {
      const targetInput = findNearestEmailInput();

      if (targetInput) {
        targetInput.scrollIntoView({ behavior: "smooth", block: "center" });
        setTimeout(() => targetInput.focus(), 600);
        return;
      }
    });
  }

  async function fetchGitHubStars() {
    try {
      const response = await fetch('https://api.github.com/repos/patroninc/patron');
      if (response.ok) {
        const data = await response.json();
        const starCount = data.stargazers_count;
        
        const formatStarCount = (count: number): string => {
          if (count >= 1000) {
            return (count / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
          }
          return count.toString();
        };
        
        const starCountElement = document.getElementById('star-count');
        if (starCountElement) {
          starCountElement.textContent = formatStarCount(starCount);
        }
      }
    } catch (error) {
      console.error('Failed to fetch GitHub star count:', error);
      const starCountElement = document.getElementById('star-count');
      if (starCountElement) {
        starCountElement.textContent = 'â˜…';
      }
    }
  }

  fetchGitHubStars();
</script>
